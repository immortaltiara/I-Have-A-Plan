# 第四周
---
*算法题+机器学习*

### 算法题
---
*挑了几道重点题写进来*
##### 正则表达式匹配
* 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
' . ' 匹配任意单个字符
' * ' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
说明:
	s 可能为空，且只包含从 a-z 的小写字母。
	p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
    
* 这道题我用的动规做。难点在于，各种情况太难一次性想全，总是会漏，所以卡了挺长时间。下面简单说一下思路。
既然是动规，那么得将题目分解。正则表达式匹配字符串，实际上为按位判断要匹配的字符串s与匹配模式p是否一致，其实这边也可以用到递归。用一个数组dp[i][j]来记录s[0 ~ i]与p[0 ~ j]是否匹配。

* 如果p[j-1]!='*'，有两种情况：
    1. 不是 '.'： 需要同时验证 s[i-1] == p[j-1] 和 前面一个是否正确
    2. 是 '.' ： 只需要验证 前面一个是否正确
    
* 如果p[j-1] == '*'
    1. 普通情况： 
        1.1. x* 前面都是正确的（x出现了0次）
        1.2. x 是正确的 （x出现了n次）
        1.3. s的当前字符 与 x* 中的x相同，并且前面都是正确的 (x出现了1次)

    2. 特殊情况（'*' 前面是 '.'）：
        2.1. 1.3. 中不需要验证 是否字符相同了。因为.可以代表任意字符。
        2.2 这个情况做的时候错了。看到测试用例才知道。对应 .* 和 aaa 这种情况，如果a一直重复，那'.'出现的时候应该是 dp[i - 1][j] 正确，就是正确的。
*   for (int i = 0; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p[j-1] == '*') {
                    if (i > 0 && (p[j-2] == s[i-1] || p[j-2] == '.')) {
                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
                    } else {
                        dp[i][j] = dp[i][j - 2];
                    }
                } else if (i > 0 && p[j-1] == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    if (i > 0 && p[j-1] == s[i-1]) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                }
            }
        }
* 后来参考了下部分题解，发现有一种动规表达式是这样的：
    1.  P[i][j] = P[i - 1][j - 1], if p[j - 1] != '*' && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
    2.  P[i][j] = P[i][j - 2], if p[j - 1] == '*' and the pattern repeats for 0 times;
    3.  P[i][j] = P[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'), if p[j - 1] == '*' and the pattern repeats for at least 1 times.
这个看起来更加简洁，把多种情况合在了一起。但按着这个写了以后实际运行时间和我的几乎相同，都是8ms,91%.
* 最优解我看了下，是回溯+动规，应该说是有着备忘录的回溯。这个交给下周仔细研究，这题花了我太长时间，现在不想看了……
##### 打乱数组
* 打乱一个没有重复元素的数组。
* 这题其实比较简单，但是里面使用了洗牌算法。
* 先说说我最开始用的算法，就是：将数组中第一个数和数组中随机位置的一个数交换位置，再将第二个数和数组中的随机位置的一个数交换，重复直到数组结束。
* vector<int> shuffle() {
         vector<int> res = v;
        for (int i = 0; i < res.size(); ++i) {
            int j =rand() % res.size();
            swap(res[i], res[t]);
        }
        return res;
* 这样是可以通过oj的，但是效率太低，512ms，16%。后来我去搜了下洗牌算法，发现其实我这个是假洗牌😂举个例子，数组[1,2,3]，按照我的洗牌方法有三轮，最后会产生27种结果；但是这个数组的全排列有6种，而27不是6的倍数，这就造成了情况不均，就是假洗牌。有一种洗牌算法，Knuth洗牌算法，和我的很相似，只要改一点：每次选随机牌j，取第i张牌时，只从前面的牌随机选出来，不从整副牌里面选就行。也就是说只要把j =rand() % res.size()改成j=i + rand() % (res.size() - i)就行了。改后变成了304ms,78%.
* 没有用swap，在我之上的包括最优解直接swap，不谈；还有一些洗牌算法比如Fisher-Yates,还没有实践
---

### 西瓜书
* 第二章和第三章在一起看。第二章的模型检验和评估方法较多，得结合后面慢慢看；第三章线性模型是我之前数学建模竞赛时候用到的，现在再看收获不小。